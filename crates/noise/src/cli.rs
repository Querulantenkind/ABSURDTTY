//! CLI definition for noise.

use clap::{Parser, Subcommand};
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "noise")]
#[command(version, about = "An unhelpful instrument that responds to commands but never solves anything")]
#[command(long_about = "
noise is a terminal tool that responds but never resolves.
It reads your mood signature (generated by tty-mood) and adapts
its tone accordingly. Without a mood signature, it works but is boring.

This is not a productivity tool. If it becomes useful, please file an incident.
")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,

    /// Seed for reproducible chaos
    #[arg(long, global = true)]
    pub seed: Option<u64>,

    /// Path to mood file (default: ~/.local/share/absurdtty/mood.json)
    #[arg(long, global = true)]
    pub mood_file: Option<PathBuf>,

    /// Output format: text, json
    #[arg(long, global = true, default_value = "text")]
    pub format: OutputFormat,
}

#[derive(Subcommand)]
pub enum Commands {
    /// Show current status and mood information
    Status,

    /// List directory contents (but weird)
    Ls {
        /// Path to list (default: current directory)
        path: Option<PathBuf>,
    },

    /// Get a diagnosis of your terminal state
    Doctor {
        /// Show verbose diagnostic information
        #[arg(long, short)]
        verbose: bool,
    },

    /// Display system uptime with philosophical commentary
    Uptime,

    /// Explain a command in deeply unhelpful ways
    Explain {
        /// The command to explain
        command: Vec<String>,
    },

    /// Generate a bureaucratic form
    Form {
        /// Form template: declaration, incident, requisition, appeal
        #[arg(long, default_value = "declaration")]
        template: String,
    },

    /// Display fake patchnotes for your terminal
    Patchnotes {
        /// Show changes since date (YYYY-MM-DD)
        #[arg(long)]
        since: Option<String>,
    },
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
pub enum OutputFormat {
    #[default]
    Text,
    Json,
}

impl std::str::FromStr for OutputFormat {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "text" => Ok(OutputFormat::Text),
            "json" => Ok(OutputFormat::Json),
            _ => Err(format!("Unknown format: {}. Use 'text' or 'json'.", s)),
        }
    }
}

