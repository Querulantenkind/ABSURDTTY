//! Reads mood signatures generated by tty-mood.

use absurd_core::Paths;
use absurd_lexicon::moods::{Mood, MoodId};
use absurd_lexicon::tone::Tone;
use anyhow::{Context, Result};
use serde::Deserialize;
use std::path::Path;

/// A loaded mood context for noise commands.
#[derive(Debug, Clone)]
pub struct MoodContext {
    /// The detected mood
    pub mood: Mood,
    /// The case ID from the signature
    pub case_id: String,
    /// The tone derived from the mood
    pub tone: Tone,
    /// Whether a mood file was found
    pub has_mood: bool,
}

impl MoodContext {
    /// Load mood context from the default or specified path.
    pub fn load(mood_file: Option<&Path>) -> Self {
        let path = mood_file
            .map(|p| p.to_path_buf())
            .or_else(|| Paths::mood_file().ok());

        match path {
            Some(p) if p.exists() => Self::from_file(&p).unwrap_or_else(|_| Self::neutral()),
            _ => Self::neutral(),
        }
    }

    /// Load from a specific file.
    fn from_file(path: &Path) -> Result<Self> {
        let content = std::fs::read_to_string(path)
            .with_context(|| format!("Failed to read mood file: {:?}", path))?;

        let signature: MoodSignature = serde_json::from_str(&content)
            .with_context(|| "Failed to parse mood signature")?;

        let mood_id = parse_mood_id(&signature.mood.id);
        let mood = Mood::new(mood_id, signature.mood.confidence)
            .with_notes(signature.notes);

        let tone = Tone::for_mood(mood_id);

        Ok(Self {
            mood,
            case_id: signature.case_id,
            tone,
            has_mood: true,
        })
    }

    /// Create a neutral context (no mood file found).
    pub fn neutral() -> Self {
        Self {
            mood: Mood::neutral(),
            case_id: "NONE".to_string(),
            tone: Tone::default(),
            has_mood: false,
        }
    }

    /// Check if we have a real mood (not neutral/missing).
    #[allow(dead_code)]
    pub fn is_active(&self) -> bool {
        self.has_mood && self.mood.id != MoodId::Neutral
    }
}

/// Minimal structure to read mood signatures.
#[derive(Debug, Deserialize)]
struct MoodSignature {
    case_id: String,
    mood: MoodInfo,
    #[serde(default)]
    notes: Vec<String>,
}

#[derive(Debug, Deserialize)]
struct MoodInfo {
    id: String,
    confidence: f64,
}

/// Parse mood ID from string.
fn parse_mood_id(s: &str) -> MoodId {
    match s.to_lowercase().replace('_', "").as_str() {
        "feralproductivity" => MoodId::FeralProductivity,
        "exhausted" => MoodId::Exhausted,
        "methodical" => MoodId::Methodical,
        "chaoticneutral" => MoodId::ChaoticNeutral,
        "bureaucraticzen" => MoodId::BureaucraticZen,
        "ambientdrift" => MoodId::AmbientDrift,
        "recursivedoubt" => MoodId::RecursiveDoubt,
        "emergencymode" => MoodId::EmergencyMode,
        _ => MoodId::Neutral,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_mood_ids() {
        assert_eq!(parse_mood_id("feral_productivity"), MoodId::FeralProductivity);
        assert_eq!(parse_mood_id("feralproductivity"), MoodId::FeralProductivity);
        assert_eq!(parse_mood_id("exhausted"), MoodId::Exhausted);
        assert_eq!(parse_mood_id("ambientdrift"), MoodId::AmbientDrift);
        assert_eq!(parse_mood_id("unknown"), MoodId::Neutral);
    }

    #[test]
    fn neutral_context() {
        let ctx = MoodContext::neutral();
        assert!(!ctx.has_mood);
        assert!(!ctx.is_active());
    }
}

